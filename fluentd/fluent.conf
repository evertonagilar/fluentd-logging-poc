<source>
  @type forward
  port 24224
  bind 0.0.0.0
  <parse>
    @type json
  </parse>
</source>

### docker.logify ###

<filter docker.logify>
  @type parser
  key_name log
  reserve_data false
  <parse>
    @type json
  </parse>
</filter>

<filter docker.logify>
  @type record_transformer
  enable_ruby true
  remove_keys emailAddress
  <record>
    hostname "#{Socket.gethostname}"
    timestamp ${Time.at(record["timestamp"]).strftime("%Y-%m-%dT%H:%M:%S.%L%z")}
    is_successful ${record["status"] == 200 ? "true" : "false"}
    ip ${record["ip"]&.gsub(/(\d+\.\d+\.\d+\.\d+)/, 'REDACTED')}
  </record>
</filter>

<match docker.logify>
  @type stdout
  <format>
  @type json
  </format>
</match>


### docker.sie ###

<filter docker.sie>
  @type parser
  key_name log
  reserve_data false
  <parse>
    @type json
  </parse>
</filter>

<filter docker.sie>
  @type grep
  key_name log
  reserve_data false

  <exclude>
    key log["MethodName"]
    pattern /^processRequest$/
  </exclude>
</filter>

# <match docker.sie>
#   @type rewrite_tag_filter
#   <parse>
#     @type json
#   </parse>
#   <rule>
#     key $.log.MethodName
#     pattern /^processRequest$/
#     tag clear
#   </rule>
# </match>



# <filter **>
#   @type grep
#   <exclude>
#     key log
#     pattern /^$/
#     # or, to exclude all messages that are empty or include only white-space:
#     # pattern /^\s*$/
#   </exclude>
# </filter>

<filter docker.sie>
  @type record_transformer
  enable_ruby true
  <record>
    k8s_container ${Socket.gethostname}
    k8s_db_error ${!record["LogMessage"].nil? && record["LogMessage"].include?("ERRORCODE=") ? true : false}
    k8s_db_error_conn ${!record["LogMessage"].nil? && record["LogMessage"].include?("ERRORCODE=-4499") ? true : false}

    # Check for SQL-related logs
    k8s_dml ${record["LoggerName"] == "org.hibernate.SQL" && !record["LogMessage"].nil? ? true : false}
    k8s_dml_insert ${record["LoggerName"] == "org.hibernate.SQL" && !record["LogMessage"].nil? && record["LogMessage"].downcase.start_with?("insert into") ? true : false}
    k8s_dml_delete ${record["LoggerName"] == "org.hibernate.SQL" && !record["LogMessage"].nil? && record["LogMessage"].downcase.start_with?("delete from") ? true : false}
    k8s_dml_select ${record["LoggerName"] == "org.hibernate.SQL" && !record["LogMessage"].nil? && record["LogMessage"].downcase.start_with?("select") ? true : false}
    k8s_dml_update ${record["LoggerName"] == "org.hibernate.SQL" && !record["LogMessage"].nil? && record["LogMessage"].downcase.start_with?("update") ? true : false}

    # Check for specific errors
    k8s_error_email ${!record["LogMessage"].nil? && record["LogMessage"].include?("MailConnectException") ? true : false}
    k8s_error_net ${!record["LogMessage"].nil? && record["LogMessage"].include?("ConnectException") ? true : false}
    k8s_error_textsearch ${!record["LogMessage"].nil? && record["LogMessage"].include?("SQLCODE=-20423") ? true : false}
    k8s_error_ejb ${!record["LogMessage"].nil? && record["LogMessage"].include?("EJBException") ? true : false}
    k8s_error_sqltimeout ${!record["LogMessage"].nil? && record["LogMessage"].include?("SQLCODE=-952") ? true : false}
    k8s_error_constraint ${!record["LogMessage"].nil? && record["LogMessage"].include?("ConstraintViolationException") ? true : false}
    k8s_error_npe ${!record["LogMessage"].nil? && record["LogMessage"].include?("NullPointerException") ? true : false}
    k8s_error_constraint_dup ${!record["LogMessage"].nil? && record["LogMessage"].include?("SQLCODE=-803") ? true : false}

    # Check for hints
    k8s_slow_hint ${!record["LogMessage"].nil? && record["LogMessage"].include?("[PERFORMANCE] ") ? true : false}


    # Check for bean-related logs
    k8s_bean_timer ${record["LoggerName"] && record["LoggerName"].end_with?("TimerBean") ? true : false}
    k8s_bean_service ${record["LoggerName"] && record["LoggerName"].end_with?("ServiceBean") ? true : false}
    k8s_bean_interceptor ${record["LoggerName"] && record["LoggerName"].end_with?("Interceptor") ? true : false}

    # Extrair verbo HTTP e URI
    k8s_req_uri ${!record["MethodName"].nil? && record["MethodName"] == "doService" && record["LogMessage"] =~ /processing (GET|POST|PUT|DELETE|HEAD|OPTIONS|PATCH) request for \[(.*?)\]/ ? $2 : nil}
    k8s_req_verb ${!record["MethodName"].nil? && record["MethodName"] == "doService" &&record["LogMessage"] =~ /processing (GET|POST|PUT|DELETE|HEAD|OPTIONS|PATCH) request for \[(.*?)\]/ ? $1 : nil}
    k8s_req_not_found ${record["LoggerName"] == "org.springframework.web.servlet.PageNotFound" ? true : false}

  </record>
</filter>


<filter docker.sie>
  @type record_transformer
  enable_ruby true
  <record>
    k8s_req_portal ${record["k8s_req_uri"].nil? ? nil : (record["k8s_req_uri"] =~ /^\/(\w+)/ ? $1 : nil)}
  </record>
</filter>


<match clear>
  @type null
</match>

<match docker.sie>
  @type stdout
  <format>
  @type json
  </format>
</match>

# <match docker.sie>
#   @type logtail
#   @id output_logify_logtail
#   source_token oJPsJtJgRbE8C2Hvs5AnJVmi
#   flush_interval 3 # in seconds
# </match>


##########################################3

# <match docker.logify.**>
#   @type logtail
#   @id output_logify_logtail
#   source_token ${ENV['TOKEN_DOCKER_LOGIFY']}
#   flush_interval 2 # in seconds
# </match>


# <match docker.nginx.**>
#   @type logtail
#   @id output_nginx_logtail
#   source_token ${ENV['TOKEN_DOCKER_NGINX']}
#   flush_interval 2 # in seconds
# </match>

# <label @FLUENT_LOG>
# <match fluent.*>
#   @type logtail
#   @id output_fluent_logtail
#   source_token ${ENV['TOKEN_FLUENT_LOG']}
#   flush_interval 2 # in seconds
# </match>
# </label>



# <match docker.nginx>
#   @type stdout
#   <format>
#   @type json
#   </format>
# </match>

